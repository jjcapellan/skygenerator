/**
 * SkyGenerator is a custom image class to create a procedural sky background using the framework Phaser 3.
 * @author       Juan Jose Capellan <soycape@hotmail.com>
 * @license      {@link https://github.com/jjcapellan/skygenerator/blob/master/LICENSE | MIT license}
 * @version      1.1.0
 */
class SkyGenerator extends Phaser.GameObjects.Image{constructor(scene,width,height,options={}){super(scene,0,0);this.scene=scene;this.width=width;this.height=height;this.backgroundColor=options.backgroundColor||35;this.globalOpacity=options.globalOpacity||.5;this.initialPointsQty=options.initialPointsQty||50;this.generatedPointsQty=options.generatedPointsQty||140;this.margin=options.margin||0;this.cloudRadius=options.cloudRadius||100;this.cloudGradient=options.cloudGradient||.5;this.starRadius=options.starRadius||3;this.starAlpha=options.starAlpha||.9;this.starHardness=options.starHardness||2/3;this.starGradient=options.starGradient||.5;this.starColors=options.starColors||[16578983,16777215,10418172];this.cloud1Color=options.cloud1Color||6675959;this.cloud2Color=options.cloud2Color||8588929;this.scaleStar2=options.scaleStar2||.8;this.scaleStar3=options.scaleStar3||.4;this.init()}init(){this.skyLayer1=[];this.skyLayer2=[];this.initMap();this.initRenderTextures();this.initCloudBrush();this.initStarBrush();this.generatePoints();this.scene.cameras.main.setBackgroundColor(this.backgroundColor);this.generateTexture();this.setTexture("rt_SkyGenerator");this.setOrigin(0)}initMap(){let rectangle=new Phaser.Geom.Rectangle(this.margin,this.margin,this.width-this.margin,this.height-this.margin);for(let i=0,j=this.initialPointsQty;i<j;i++){let point=rectangle.getRandomPoint();let opacity=Math.random()*this.globalOpacity+.05;this.skyLayer1.push([point.x,point.y,opacity]);point=rectangle.getRandomPoint();opacity=Math.random()*this.globalOpacity+.05;this.skyLayer2.push([point.x,point.y,opacity])}this.skyLayer1.push([this.margin,this.margin,Math.random()]);this.skyLayer2.push([this.margin,this.margin,Math.random()])}initRenderTextures(){let cloudWidth=this.cloudRadius*2;this.cloudTexture=this.scene.make.renderTexture({width:cloudWidth,height:cloudWidth},false).setVisible(false);let starWidh=this.starRadius*2;this.star1Texture=this.scene.make.renderTexture({width:starWidh,height:starWidh},false).setVisible(false);this.star2Texture=this.scene.make.renderTexture({width:starWidh*this.scaleStar2,height:starWidh*this.scaleStar2},false).setVisible(false);this.star3Texture=this.scene.make.renderTexture({width:starWidh*this.scaleStar3,height:starWidh*this.scaleStar3},false).setVisible(false)}initCloudBrush(){this.cloudTexture.draw(this.makeBrush(1,this.cloudRadius,this.cloudGradient,false),this.cloudTexture.width/2,this.cloudTexture.width/2)}initStarBrush(){this.star1Texture.draw(this.makeBrush(1,this.starRadius,this.starGradient,true),this.star1Texture.width/2,this.star1Texture.width/2);this.star2Texture.draw(this.makeBrush(this.scaleStar2,this.starRadius,this.starGradient,true),this.star2Texture.width/2,this.star2Texture.width/2);this.star3Texture.draw(this.makeBrush(this.scaleStar3,this.starRadius,this.starGradient,true),this.star3Texture.width/2,this.star3Texture.width/2)}makeBrush(scale,initialRadius,gradient,isStar){let brush=this.scene.add.graphics();let radius=Math.round(initialRadius*scale);let steps=Math.round(200*gradient);let k=(radius-1)/(steps*steps);let alpha=this.starAlpha/steps;let prevRadius=0;if(alpha<.005)alpha=.005;brush.setVisible(false);for(let i=0;i<radius+1;i++){brush.fillStyle(16777215,alpha);let r=Math.round(1+i*i*k);if(r<1)r=1;if(r>radius)r=radius;if(r==prevRadius){continue}else{prevRadius=r}brush.fillCircle(0,0,r)}if(isStar){if(this.starHardness==0)this.starHardness=.001;brush.fillStyle(16777215,this.starAlpha);brush.fillCircle(0,0,radius*this.starHardness)}return brush}generateTexture(){let rt=this.scene.make.renderTexture({x:0,y:0,width:this.width,height:this.height},false);rt.setOrigin(0,0);for(let i=0,j=this.skyLayer1.length;i<j;i++){let cloudScale=Math.random()*.4+.6;this.cloudTexture.setPosition(this.skyLayer1[i][0],this.skyLayer1[i][1]).setTint(this.cloud1Color).setAlpha(this.skyLayer1[i][2]/3).setScale(cloudScale,cloudScale).setVisible(false);rt.draw(this.cloudTexture);this.cloudTexture.setPosition(this.skyLayer2[i][0],this.skyLayer2[i][1]).setTint(this.cloud2Color).setAlpha(this.skyLayer2[i][2]/3).setScale(cloudScale,cloudScale).setVisible(false);let starTexture=Phaser.Math.RND.pick([this.star1Texture,this.star2Texture,this.star3Texture]);starTexture.setPosition(this.skyLayer2[i][0],this.skyLayer2[i][1]).setAlpha(this.skyLayer2[i][2]*(this.starAlpha/this.globalOpacity)).setTint(Phaser.Math.RND.pick(this.starColors));rt.draw([this.cloudTexture,starTexture])}rt.saveTexture("rt_SkyGenerator")}generatePoints(){for(let i=0;i<this.generatedPointsQty;i++){let point1=Phaser.Math.RND.pick(this.skyLayer1);let point2=Phaser.Math.RND.pick(this.skyLayer1);let point3=Phaser.Math.RND.pick(this.skyLayer1);let x=Phaser.Math.Average([point1[0],point2[0],point3[0]]);let y=Phaser.Math.Average([point1[1],point2[1],point3[0]]);let opacity=Phaser.Math.Average([point1[2],point2[2],point3[0]])+(Math.random()*10-10)/100;opacity=Phaser.Math.Clamp(opacity,.05,this.globalOpacity);this.skyLayer1.push([x,y,opacity]);point1=Phaser.Math.RND.pick(this.skyLayer1);point2=Phaser.Math.RND.pick(this.skyLayer1);point3=Phaser.Math.RND.pick(this.skyLayer1);x=Phaser.Math.Average([point1[0],point2[0],point3[0]]);y=Phaser.Math.Average([point1[1],point2[1],point3[0]]);opacity=Phaser.Math.Average([point1[2],point2[2],point3[0]])+(Math.random()*10-10)/100;opacity=Phaser.Math.Clamp(opacity,.05,this.globalOpacity);this.skyLayer2.push([x,y,opacity])}}}